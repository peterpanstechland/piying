皮影数字动捕控制理论与算法白皮书

本文档旨在总结将 3D 人体姿态（MediaPipe）映射到 2D 侧面皮影（Shadow Puppet）的核心控制理论。本系统主要解决三大挑战：维度压缩（3D转2D）、自遮挡处理（Self-Occlusion）以及信号稳定性（Stability）。

1. 系统架构数据流 (Data Pipeline)

整个动捕系统应遵循以下数据处理管线：

Input (MediaPipe Landmarks) 
  --> [1. 信号预处理 & 滤波] 
  --> [2. 归一化 & 校准] 
  --> [3. 意图分析 & 状态机] (转身/抬腿/下蹲判定)
  --> [4. 运动学解算] (FK / IK 混合求解)
  --> [5. 物理后处理] (惯性/跟随)
  --> Output (SVG/Canvas Render)


2. 核心模块详解

2.1 信号预处理 (Signal Preprocessing)

问题描述： 原始 MediaPipe 数据存在高频噪声（Jitter），导致皮影关节像触电一样抖动。

解决方案：双重滤波策略

低通滤波 (Low-Pass Filter / Lerp):

用于平滑关节角度。

算法：CurrentVal = Lerp(PrevVal, TargetVal, SmoothFactor)

参数：SmoothFactor 建议在 0.1 (平滑但有延迟) 到 0.3 (灵敏但有抖动) 之间动态调整。

置信度阈值 (Confidence Gate):

MediaPipe 提供每个点的 visibility 分数。

策略：若 visibility < 0.5，停止更新该关节，保持上一帧状态或插值归位到自然姿态，防止关节乱飞。

2.2 空间映射策略 (Spatial Mapping: Front-to-Side)

问题描述： 用户正对屏幕（Frontal View），皮影是侧面（Profile View）。直接映射 X 轴会导致皮影变扁。

解决方案：骨骼角度重定向 (Angle Retargeting)

核心原则： 抛弃位置（Position），只取角度（Rotation）。

局部坐标系： 计算子骨骼相对于父骨骼的 3D 向量。

例如手臂：计算 Vector(Shoulder -> Elbow)。

提取该向量在“冠状面”（Coronal Plane）上的投影角度，直接应用给皮影的旋转节点。

结果： 用户侧平举手（X轴变化），皮影向前平举手。逻辑上都是“举手”，视觉上符合各自维度的透视。

2.3 状态机设计 (State Machines)

A. 转身逻辑 (Turning Mechanism)

输入： 左肩与右肩的 Z 轴深度差 (DiffZ = Left.z - Right.z) 或 头部 Yaw 角。

难点： 临界点抖动（Z-fighting）。

解法：迟滞比较器 (Hysteresis Comparator)

设置死区（Deadzone）：[-0.15, +0.15]。

逻辑：

当前朝右：只有当 DiffZ < -0.15 时，才切换朝左。

当前朝左：只有当 DiffZ > +0.15 时，才切换朝右。

效果：用户必须明显转体才能触发转身，彻底消除闪烁。

B. 缩放逻辑 (Scaling Strategy)

错误做法： 使用“肩宽”作为缩放基准。因为用户转身时，肩宽在 2D 画面上会变窄，导致皮影忽大忽小。

正确做法： 使用 “躯干高度” (Torso Height) 或 “大腿长度” 作为基准。这些骨骼在垂直方向，受转身透视影响最小。

公式： Scale = ReferenceHeight / CurrentTorsoPixelHeight。

2.4 腿部与遮挡处理 (Legs & Occlusion)

问题描述： 正对摄像头抬腿时，大腿指向镜头，2D 投影长度变短，且遮挡小腿。

解决方案：启发式算法 + 自动补全 (Heuristics & Auto-Complete)

动作

视觉特征 (2D Heuristics)

映射策略

高抬腿

1. 膝盖 Y 轴显著上升 (高于 Hip 初始位置)



2. 大腿投影长度显著变短 (Ratio < 0.7)

自动补全： 忽略混乱的小腿数据，强制将皮影小腿设为自然下垂或微弯，大腿设为 90度抬起。

后踢腿

1. 膝盖 Y 轴基本不变



2. 脚踝 Y 轴显著上升 (靠近臀部)

逆向推导： 保持大腿不动，根据脚踝上升的高度反算小腿弯曲角度。

行走/站立

1. 膝盖与脚踝均在自然范围内

IK 介入： 启用地面吸附逻辑。

2.5 运动学解算 (Kinematics Solver)

这是让皮影“脚踏实地”的关键。

A. 混合解算流程 (Hybrid Solver)

判定意图： 用户是在做大幅度动作（踢腿/跳跃），还是仅仅在移动/下蹲？

分支处理：

大幅动作： 切换到 FK (正向运动学)。直接映射关节角度，允许脚离地。

站立/下蹲： 切换到 IK (逆向运动学)。

B. 解析式 IK 算法 (2-Bone Analytic IK)

已知： 髋部位置 (Hip)、地面高度 (GroundY)、大腿长 (L1)、小腿长 (L2)。

目标： 求大腿角度 ($\theta_1$) 和膝盖角度 ($\theta_2$)。

核心数学 (余弦定理)：

设 $D$ 为髋部到脚底的直线距离。

$D = \text{Clamp}(GroundY - HipY, 0, L1+L2)$

膝盖内角 $\alpha = \arccos(\frac{L1^2 + L2^2 - D^2}{2 \cdot L1 \cdot L2})$

地面吸附 (Grounding)： 无论 MediaPipe 测量的脚在哪，强制设定 TargetFootY = GroundY。

3. 细节优化与物理层

物理惯性 (Secondary Motion / Lag)

不要让所有部件都 1:1 跟随。

对于袖子、发梢、挂饰：使用 Verlet Integration 或简单的延迟跟随算法。

SleeveAngle = Lerp(SleeveAngle, ArmAngle, 0.05) (极低的平滑系数)。

效果：手臂停下后，袖子会继续摆动，增加韵味。

比例校准 (Calibration)

程序启动时检测用户的初始 T-Pose。

记录用户的 BaseTorsoLength。

后续所有计算使用 CurrentLength / BaseLength 的比率，而非绝对像素值。这解决了儿童和成人身高不同导致的皮影关节错位问题。

4. 常见问题排查清单 (Troubleshooting)

皮影腿部抽搐： 检查 IK 目标距离是否超出 L1+L2。必须在算法中加入 Math.min(dist, maxReach - epsilon) 进行钳制，防止三角形无法闭合导致的数学计算错误 (NaN)。

转身时皮影瞬间变小： 缩放基准选错了，改用躯干高度，并对 Scale 值本身也做一次 Lerp 平滑。

侧身时手打结： 手臂 IK 需要加入关节约束 (Constraint)。皮影的肘部只能向后弯，不能向前反关节。在计算 acos 时强制取正值或负值来约束方向。

📋 可调参数总览
1. PoseFilter（信号滤波）
参数	作用	默认值	调整方向
smoothFactor	低通滤波强度	0.15	↑抖=降低，↑慢=提高
visibilityThreshold	置信度门槛	0.5	丢失多=降低，乱飞=提高
holdFrames	丢失后保持帧数	5	闪烁=增加
velocityThreshold	动态平滑的速度阈值	0.05	快动作迟钝=降低
2. TurnStateMachine（转身）
参数	作用	默认值	调整方向
deadzone	死区范围	±0.15	闪烁=扩大，不灵敏=缩小
turnAnimationDuration	转身动画时长	300ms	太快=增加，太慢=减少
3. ScaleProcessor（缩放）
参数	作用	默认值	调整方向
scaleSmoothFactor	缩放值平滑系数	0.1	忽大忽小=降低
minScale / maxScale	缩放范围限制	0.5 / 2.0	根据场景需求
4. LegProcessor（腿部检测）
参数	作用	默认值	调整方向
kneeRiseThreshold	膝盖上升阈值	0.08	检测太灵敏=提高
thighRatioThreshold	大腿缩短比率阈值	0.7	漏检=提高
ankleRiseThreshold	脚踝上升阈值（后踢）	0.1	漏检=降低
liftThreshold	单脚抬起阈值	0.05	走路检测灵敏度
5. IKSolver（逆运动学）
参数	作用	默认值	调整方向
groundY	地面高度	0.9	脚悬空=降低，脚陷地=提高
thighLength	大腿长度	自动校准	比例失调时手动调
shinLength	小腿长度	自动校准	同上
epsilon	安全边距	0.01	NaN 问题时增加
6. SecondaryMotion（物理惯性）
参数	作用	默认值	调整方向
followFactor	跟随系数	0.05	效果不明显=降低
damping	阻尼系数	0.9	摆动太久=降低
🎛️ 参数数量统计
模块	参数数量
PoseFilter	4
TurnStateMachine	2
ScaleProcessor	3
LegProcessor	4
IKSolver	4
SecondaryMotion	2
总计	~19 个参数
💡 好消息：可以简化！
虽然参数多，但有几个策略可以降低调试难度：
策略 1: 分层默认值
大部分参数用经过验证的默认值，只暴露 3-5 个最关键的给用户调：
smoothFactor (抖动 vs 延迟)
deadzone (转身灵敏度)
groundY (地面高度)
策略 2: 预设配置
提供几套预设：
const PRESETS = {  '稳定优先': { smoothFactor: 0.1, deadzone: 0.2 },  // 适合表演  '灵敏优先': { smoothFactor: 0.25, deadzone: 0.1 }, // 适合游戏  '儿童模式': { visibilityThreshold: 0.3 },          // 动作幅度小}
策略 3: 自动校准
校准时自动计算部分参数：
thighLength / shinLength → 从 T-Pose 自动测量
groundY → 从脚踝位置自动推断
🎯 调参优先级
如果你觉得参数太多，按这个顺序调：
最重要 → smoothFactor（解决抖动，这是最明显的问题）
次重要 → deadzone（解决转身闪烁）
第三 → groundY（解决脚不着地）
其他 → 遇到具体问题再针对性调

🧪 分阶段测试策略
阶段 1：单模块隔离测试
每个模块单独测试，确保基础功能正确：
模块	测试方法	预期结果
PoseFilter	用手快速晃动，然后静止	皮影不应该"像触电一样抖"
TurnStateMachine	缓慢左右转身	不应该在正对镜头时反复闪烁翻转
ScaleProcessor	前后走动、转身	皮影大小应该稳定，不忽大忽小
LegProcessor	做踢腿、抬腿动作	控制台应打印正确的意图识别
IKSolver	下蹲、站立	皮影脚应该"踩在地上"不飘
阶段 2：调试可视化面板
在 CameraTestPage 中添加实时数据展示：
┌─────────────────────────────────────┐│  [调试面板]                          ││                                     ││  当前状态: STANDING                  ││  朝向: LEFT (死区内: ✓)              ││  缩放: 1.02 (基准躯干: 0.35)          ││                                     ││  滤波后角度:                         ││    左臂: 45.2° (原始: 47.8°)         ││    右臂: -12.3° (原始: -15.1°)       ││                                     ││  腿部意图: HIGH_KICK (左腿)           ││  IK: θ1=30° θ2=60° (D=0.42)         ││                                     ││  [参数调节]                          ││  平滑系数: [===●====] 0.15           ││  死区范围: [==●=====] 0.12           │└─────────────────────────────────────┘
🔍 常见问题排查清单
根据白皮书，这些是最常见的问题和解决方案：
问题 1: 皮影关节抖动/抽搐
现象: 关节像触电一样不停颤抖
排查步骤:
打开调试面板，观察原始角度 vs 滤波后角度
如果两者几乎相同 → 滤波没生效
如果差距太大 → 延迟太高
解决方案:
// 调整平滑系数smoothFactor = 0.15  // 太抖就降低，太慢就提高
问题 2: 转身时反复闪烁
现象: 正对摄像头时皮影不停左右翻转
排查步骤:
打印 shoulderDepthDiff 值
观察是否在 0 附近反复跳动
解决方案:
// 检查死区设置if (Math.abs(depthDiff) < 0.15) {  // 在死区内，保持当前朝向不变  return currentFacing}
问题 3: 转身时皮影突然变小
现象: 侧身→正对时皮影尺寸剧烈变化
原因: 用肩宽作为缩放基准（转身时肩宽投影变窄）
解决方案:
// 改用躯干高度const torsoHeight = distance(shoulder, hip)  // Y轴方向，不受转身影响const scale = referenceHeight / torsoHeight
问题 4: 腿部动作识别错误
现象: 明明在抬腿，但识别为站立
排查步骤:
打印膝盖 Y 坐标变化量
打印大腿投影长度比率
调试输出示例:
[LegProcessor]   膝盖Y变化: 0.12 (阈值: 0.08) ✓  大腿长度比: 0.65 (阈值: 0.70) ✓  → 判定: HIGH_KICK
问题 5: IK 计算出 NaN
现象: 控制台报错，腿部位置乱飞
原因: acos 输入超出 [-1, 1] 范围
解决方案:
// 在 IKSolver 中添加保护const cosAngle = (L1*L1 + L2*L2 - D*D) / (2 * L1 * L2)const safeCos = Math.max(-1, Math.min(1, cosAngle))  // 钳制到有效范围const angle = Math.acos(safeCos)
📊 关键指标监控
在测试过程中，建议实时监控这些数值：
指标	正常范围	异常信号
帧率 (FPS)	> 25	< 15 表示性能问题
关节 visibility	> 0.5	< 0.3 数据不可信
角度变化速度	< 30°/帧	> 60°/帧 可能是噪声
肩膀深度差	-0.5 ~ 0.5	超出表示数据异常
IK 目标距离 D	< L1+L2	= L1+L2 表示超伸
🛠️ 调试代码模板
在每个模块中添加可开关的调试日志：
class PoseFilter {  private debug = false  // 可通过UI开关    filter(landmarks: PoseLandmarks): PoseLandmarks {    // ... 滤波逻辑 ...        if (this.debug && this.frameCount % 30 === 0) {      console.table({        '左肩原始': { x: raw.x.toFixed(3), y: raw.y.toFixed(3) },        '左肩滤波': { x: filtered.x.toFixed(3), y: filtered.y.toFixed(3) },        '变化量': { dx: (raw.x - filtered.x).toFixed(4) }      })    }  }}
🎯 测试动作清单
执行这些标准动作，覆盖所有功能：
T-Pose 校准 → 验证 CalibrationManager
缓慢挥手 → 验证 PoseFilter 平滑效果
快速挥手 → 验证动态平滑不会太迟钝
180° 转身 → 验证 TurnStateMachine 死区
前后走动 → 验证 ScaleProcessor 稳定性
正对镜头抬腿 → 验证 LegProcessor 高抬腿检测
向后踢腿 → 验证后踢腿检测
下蹲站起 → 验证 IK 地面吸附
停止不动 3 秒 → 验证静止时无抖动